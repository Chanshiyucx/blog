## 01 Vue2 和 Vue3 的响应式原理？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？

Vue2 通过 Object.defineProperty 来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。Vue 3.0 实现响应式基于 ES6 的 Proxy。

1. Object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
2. Object.defineProperty 只能劫持对象的属性，无法检测到对象属性的添加和删除，并且如果属性值是对象，还需要深度遍历，深度监听对性能影响比较大。
3. Proxy 可以直接监听数组的变化；
4. Proxy 可以直接监听对象而非属性，所以可以监听对象属性的添加和删除，Proxy 直接可以劫持整个对象，并返回一个新对象，可以只操作新的对象达到响应式目的；而 Object.defineProperty 只能遍历对象属性直接修改；
5. Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，得到新标准的性能红利，而 Object.defineProperty 兼容 IE。

## 02 Vue 组件中 data 为什么必须是一个函数？

vue 中组件是可以复用，为了防止 data 复用，需要将其定义为函数。

组件中的 data 写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的 data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个 data，这样改一个全都改了。

## 03 Vue 的双向绑定和单向数据流冲突吗?

单双向数据绑定与数据流是两个不同维度的概念，**数据绑定是 View 与 Model 之间的映射关系，数据流指的是组件之间的数据流动**。两者不应该混为一谈。

- 单向绑定：插值形式{{data}}，v-bind 也是单向绑定
- 双向绑定：表单的 v-model，用户对 View 层的更改会直接同步到 Model 层

Vue 与 React 都是单向数据流的模型，虽然 vue 有双向绑定 v-model，但是 vue 和 react 父子组件之间数据传递，仍然还是遵循单向数据流的，父组件可以向子组件传递 props，但是子组件不能修改父组件传递来的 props，子组件只能通过事件通知父组件进行数据更改。

## 04 nextTick 的作用和原理是什么？

Vue 在更新 DOM 时是异步执行的，当数据发生变化，Vue 将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新。nextTick 的作用就是可以将里面的回调函数延迟下次 DOM 更新循环结束之后执行。在修改数据之后立即使用这个方法，获取更新后的 DOM。

实现原理：nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用：

- Promise：可以将函数延迟到当前函数调用栈最末端；
- MutationObserver：是 H5 新加的一个功能，其功能是监听 DOM 节点的变动，在所有 DOM 变动完成后，执行回调函数；
- setImmediate：用于中断长时间运行的操作，并在浏览器完成其他操作（如事件和显示更新）后立即运行回调函数；
- 如果以上都不行则采用 setTimeout 把函数延迟到 DOM 更新之后再使用，原因是宏任务消耗大于微任务，优先使用微任务，最后使用消耗最大的宏任务。

## 05 Vue3 watch 和 watchEffect 的使用方式和场景上的区别？

- watch 和 watchEffect 都能监听响应式数据的变化，不同的是它们监听数据变化的方式不同。
- watch 需要传入侦听的数据源，而 watchEffect 是自动收集数据源作为依赖。
- watch 在响应数据初始化时是不会执行回调函数的，除非设置 immediate，watchEffect 在响应数据初始化时就会立即执行回调函数。
- watch 可以访问侦听状态变化前后的值，而 watchEffect 只能获取改变后的值。

## 06 Vue 3 中 Treeshaking 特性实现原理与好处？

是什么？

Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，就是在保持代码运行结果不变的前提下，去除无用的代码。

在 Vue2 中，无论使用什么功能，它们最终都会出现在生产代码中。主要原因是 Vue 实例在项目中是单例的，无法检测到对象的哪些属性在代码中被使用到。

而 Vue3 源码引入 tree shaking 特性，将全局 API 进行分块，如果不使用某些功能，它们将不会包含在最后的打包代码中。

怎么做？

Tree shaking 是基于 ES6 模板语法（import 与 exports），主要是借助 ES6 模块的**静态编译**思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量。

tree shaking 无非就是做了两件事：

- 编译阶段利用 ES6 Module 判断哪些模块已经加载；
- 判断那些模块和变量未被使用或者引用，进而删除对应代码；

好处？

通过 Tree shaking，Vue3 给带来的好处是：

- 减少程序体积（更小）
- 减少程序执行时间（更快）
- 便于将来对程序架构进行优化

## 07 函数节流和函数防抖？

函数节流（throttle）与函数防抖（debounce）核心思想都是通过限制函数调用来实现性能优化，但两者概念却有不同：

- 函数节流：函数按指定间隔调用，限制函数调用频率
- 函数防抖：一定时间段连续的函数调用，只让其执行一次

两者的使用场景也有不同：

- 函数节流：页面滚动事件监听（scroll）、DOM 元素拖拽（mousemove）、键盘事件（keydown）
- 函数防抖：文本输入验证发送请求、窗口缩放（resize）

## 08 Typescript 中 interface 和 type 区别？

相同点：

1. 都可以描述一个对象或者函数；
2. 都允许拓展；

不同点：

1. type 可以声明基本类型别名，联合类型，元组等类型；
2. type 语句中还可以使用 typeof 获取实例的类型进行赋值；
3. interface 能够声明合并；type 一个类型只能声明一次；

> 引申：如果用 interface 多次声明同一个名称的接口，结果会怎么样？【声明合并，多次声明取并集】

## 09 Typescript 类型映射？

1. 可选类型 Partial：用于将 T 类型的所有属性设置为可选状态；
2. 必选类型 Required：用于将 T 类型的所有属性设置为必选状态；
3. 提取属性 Pick：从 T 类型中提取部分属性，作为新的返回类型；
4. 排除属性 Omit：用于从 T 类型中，排除部分属性，然后返回一个新类型；
5. 摘取类型 Extract<T,U>：提取 T 中可以赋值给 U 的类型【交集】；
6. 排除类型 Exclude<T,U>：从 T 中剔除可以赋值给 U 的类型【差集】。

## 10 declare，declare global 是什么？

- declare 是用来定义全局变量、全局函数、全局命名空间、js modules、class 等；
- declare global 为全局对象 window 增加新的属性。

## 11 XSS 和 CSRF 攻击？

- XSS：跨站脚本攻击，用攻击者通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求之类的操作。
- CSRF：跨站请求伪造，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。CSRF 并不能够拿到用户的任何信息，它只是欺骗用户浏览器，让其以用户的名义进行操作。

扩展：如何防护？

XSS：所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，防御 XSS 攻击最简单直接的方法，就是过滤用户的输入
CSRF：

1. 验证码
2. 验证 HTTP Referer 字段
3. 添加 token，而不是 cookie

## 01 触发自定义事件

```javascript
window.addEventListener('resize', function () {
  console.log('当前页面缩放比例应该是：' + Math.round(1000 * (outerWidth / innerWidth)) / 10 + '%')
})
window.dispatchEvent(new CustomEvent('resize'))
```

## 02 判断奇偶

```javascript
n & 1 // 和 n % 2 结果一致，偶数返回 0，奇数返回 1
```

## 03 [useLayoutEffect 和 useEffect 的区别](https://zhuanlan.zhihu.com/p/348701319)

### 差异

- useEffect 是异步执行的，而 useLayoutEffect 是同步执行的。
- useEffect 的执行时机是浏览器完成渲染之后，而 useLayoutEffect 的执行时机是浏览器把内容真正渲染到界面之前，和 componentDidMount、componentDidUpdate 等价。

### ssr

useLayoutEffect 不会在服务端执行，所以就有可能导致 ssr 渲染出来的内容和实际的首屏内容并不一致。

而解决这个问题也很简单：

- 放弃使用 useLayoutEffect，使用 useEffect 代替
- 如果你明确知道 useLayouteffect 对于首屏渲染并没有影响，但是后续会需要，你可以这样写：

```javascript
import { useEffect, useLayoutEffect } from 'react'

export const useCustomLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect
```

### 总结

- 优先使用 useEffect，因为它是异步执行的，不会阻塞渲染。
- 会影响到渲染的操作尽量放到 useLayoutEffect 中去，避免出现闪烁问题。
- useLayoutEffect 和 componentDidMount、componentDidUpdate 是等价的，会同步调用，阻塞渲染。
- useLayoutEffect 在服务端渲染的时候使用会有一个 warning，因为它可能导致首屏实际内容和服务端渲染出来的内容不一致。

## 04 substr 与 substring 的区别

定义：

- substr(start,length) 第一个字符的索引是 0，start 必选，length 可选
- substring(start,end) 第一个字符的索引是 0，start 必选，end 可选

异同：

- 相同点：当有一个参数时，两者的功能是一样的，返回从 start 指定的位置直到字符串结束的子串
- 不同点：有两个参数时，
  - substr(start,length) 返回从 start 位置开始 length 长度的子串
  - substring(start,end) 返回从 start 位置开始到 end 位置的子串（不包含 end）

## 05 [CSS 逻辑属性](https://www.zhangxinxu.com/wordpress/2022/12/css-logic-property-for-write/)

所谓逻辑属性，指的是诸如类似 margin-inline-start，padding-block-end 这类包含 inline/block 和 start/end 关键字的 CSS 属性。

**其中 inline 和 block 表示方向， start 和 end 表示起止方位。**在中文和英文网页环境中，inline 元素默认是从左往右水平排列的；block 元素默认是从上往下垂直排列的。因此，margin-inline-start 就表示内联元素排列方向的起始位置，就是“左侧”，margin-inline-end 就表示内联元素排列方向的终止位置，就是“右侧”。

margin：

```css
/* 四方位 */
margin-top
margin-right
margin-bottom
margin-left

/* 水平与垂直 */
margin-inline
margin-block
```

border-block：样式布局同时设置上下边框的场景

```css
/* 过去 1 */
border: solid #ddd;
border-width: 1px 0;

/* 过去 2 */
border-top: 1px solid #ddd;
border-bottom: 1px solid #ddd;

/* 现在 */
border-block: 1px solid #ddd;
```

inset 及其相关属性是 left/top/right/bottom 属性的缩写。一种全局覆盖层的情景如下：

```css
/* 过去 */
.overlay {
  position: fixed;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
}

/* 现在 */
.overlay {
  position: fixed;
  inset: 0;
}
```

如果是水平方向的拉伸，则也不需要 left: 0; right: 0，可以使用 inset-inline 属性进行设置：

```css
.header-bar {
  inset-inline: 0;
}
```

CSS 逻辑属性的兼容性已经可以放心使用。

## 06 [模拟微信对话的对称布局](https://demo.cssworld.cn/new/3/2-3.php)

```html
<section class="msg-item">
  <img class="msg-avator" alt="武元润香" src="../images/bg-1.jpg" />
  <div class="msg-info">
    <span class="msg-user">武元润香</span>
    <div class="msg-txt">
      <p>没问题哟~</p>
    </div>
  </div>
</section>
<section class="msg-item" data-self>
  <img class="msg-avator" alt="唯我成幸" src="../images/bg-2.jpg" />
  <div class="msg-info">
    <span class="msg-user">唯我成幸</span>
    <div class="msg-txt">
      <p>大家有什么想要了解的吗？</p>
    </div>
  </div>
</section>
```

```css
/* 设置direction:rtl，则水平文档流方向就是从右往左 */
.msg-item[data-self] {
  direction: rtl;
}
```

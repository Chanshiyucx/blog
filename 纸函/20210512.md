## 01 [Storage 接口](https://wangdoc.com/javascript/bom/storage.html)

Storage 接口的属性和方法如下：

```js
localStorage.length
localStorage.setItem()
localStorage.getItem()
localStorage.removeItem()
localStorage.clear()
localStorage.key()

// localStorage 可以直接赋值，等价于 setItem，以下三种方式等价：
localStorage.foo = '123'
localStorage['foo'] = '123'
localStorage.setItem('foo', '123')
```

`Storage.key()` 方法接受一个整数作为参数（从零开始），返回该位置对应的键名。

```js
window.sessionStorage.setItem('key', 'value')
window.sessionStorage.key(0) // "key"
```

结合使用 `Storage.length` 属性和 `Storage.key()` 方法，可以遍历所有的键。

```js
for (var i = 0; i < window.localStorage.length; i++) {
  console.log(localStorage.key(i))
}
```

Storage 接口储存的数据发生变化时，会触发 storage 事件，可以指定这个事件的监听函数。

```js
window.addEventListener('storage', onStorageChange)
```

监听函数接受一个 event 实例对象作为参数。这个实例对象继承了 StorageEvent 接口，有几个特有的属性，都是只读属性。

- `StorageEvent.key`：字符串，表示发生变动的键名。如果 storage 事件是由 `clear()` 方法引起，该属性返回 null。
- `StorageEvent.newValue`：字符串，表示新的键值。如果 storage 事件是由 `clear()` 方法或删除该键值对引发的，该属性返回 null。
- `StorageEvent.oldValue`：字符串，表示旧的键值。如果该键值对是新增的，该属性返回 null。
- `StorageEvent.storageArea`：对象，返回键值对所在的整个对象。也说是说，可以从这个属性上面拿到当前域名储存的所有键值对。
- `StorageEvent.url`：字符串，表示原始触发 storage 事件的那个网页的网址。

下面是 `StorageEvent.key` 属性的例子。

```js
function onStorageChange(e) {
  console.log(e.key)
}

window.addEventListener('storage', onStorageChange)
```

注意，该事件有一个很特别的地方，就是它不在导致数据变化的当前页面触发，而是在同一个域名的其他窗口触发。也就是说，如果浏览器只打开一个窗口，可能观察不到这个事件。比如同时打开多个窗口，当其中的一个窗口导致储存的数据发生改变时，只有在其他窗口才能观察到监听函数的执行。可以通过这种机制，实现多个窗口之间的通信。

02 触发自定义事件

```js
window.addEventListener('resize', function () {
  console.log('当前页面缩放比例应该是：' + Math.round(1000 * (outerWidth / innerWidth)) / 10 + '%')
})
window.dispatchEvent(new CustomEvent('resize'))
```

## 03 [HTML 字符的转义和反转义](https://www.zhangxinxu.com/wordpress/2021/01/dom-api-html-encode-decode/)

### 转义

```js
let textNode = document.createTextNode('<span>by zhangxinxu</span>')
let div = document.createElement('div')
div.append(textNode)
console.log(div.innerHTML)
// &lt;span&gt;by zhangxinxu&lt;/span&gt;
```

也就是把 HTML 内容作为文本节点的 textContent 内容，然后使用普通元素的 innerHTML 属性返回下就可以了。

### 反转义

可以使用 DOMParser API：

```js
let str = '&lt;span&gt;by zhangxinxu&lt;/span&gt;'
let doc = new DOMParser().parseFromString(str, 'text/html')
console.log(doc.documentElement.textContent)
// <span>by zhangxinxu</span>
```

或者借助 `<textarea>` 元素：

```js
let textarea = document.createElement('textarea')
textarea.innerHTML = '&lt;span&gt;by zhangxinxu&lt;/span&gt;'
console.log(textarea.childNodes[0].nodeValue)
// <span>by zhangxinxu</span>
```

### DOM API 方法的缺点

DOM API 方法利用了浏览器的能力，更容易上手，转义结果也更安全，但是有个不足，那就是只能在浏览器上下文环境中使用。例如，如果是 Service Workers 环境，或者是 Node.js 环境中，这个方法就不行了，只能使用传统的字符串处理方法了。
传统的字符串处理代码示意：

```js
/**
 * 转义HTML标签的方法
 * @param  {String} str 需要转义的HTML字符串
 * @return {String}     转义后的字符串
 */
var funEncodeHTML = function (str) {
  if (typeof str == 'string') {
    return str.replace(/<|&|>/g, function (matches) {
      return {
        '<': '&lt;',
        '>': '&gt;',
        '&': '&amp;',
      }[matches]
    })
  }

  return ''
}

/**
 * 反转义HTML标签的方法
 * @param  {String} str 需要反转义的字符串
 * @return {String}     反转义后的字符串
 */
var funDecodeHTML = function (str) {
  if (typeof str == 'string') {
    return str.replace(/&lt;|&gt;|&amp;/g, function (matches) {
      return {
        '&lt;': '<',
        '&gt;': '>',
        '&amp;': '&',
      }[matches]
    })
  }

  return ''
}
```
